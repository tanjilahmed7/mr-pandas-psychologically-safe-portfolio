/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { useKTX2Texture } from "../utils/ktxLoader";
import { SHIFT_X_AMOUNT } from "../components/curve";
import { useFrame } from "@react-three/fiber";
import { gsap } from "gsap";
import * as THREE from "three";

export default function Model({ scrollProgress, ...props }) {
  const { nodes, materials } = useGLTF("/models/single_sheet.glb");

  const singlesheet = useKTX2Texture("/textures/single_sheet.ktx2");
  const kpop = useKTX2Texture("/textures/kpop.ktx2");

  const kpopRumiRef = useRef();
  const kpopSignRef = useRef();

  const kpopRumiGroupRef = useRef();
  const kpopSignGroupRef = useRef();

  const lastScrollStateRumi = useRef(null);
  const lastScrollStateSign = useRef(null);

  const [randomOffsets] = useState(() => ({
    kpopRumi: {
      position: new THREE.Vector3(),
      rotation: new THREE.Euler(),
      time: Math.PI * 0.5,
      basePosition: new THREE.Vector3(0, 0, 0),
      baseRotation: new THREE.Euler(Math.PI / 2, 0.058, -Math.PI),
    },
    kpopSign: {
      position: new THREE.Vector3(),
      rotation: new THREE.Euler(),
      time: Math.PI * 0.9,
      basePosition: new THREE.Vector3(0, 0, 0),
      baseRotation: new THREE.Euler(Math.PI / 2, -0.06, 0),
    },
  }));

  useFrame((state, delta) => {
    const t = state.clock.elapsedTime;
    const currentProgress = scrollProgress.current;

    const isAbove089 = currentProgress >= 0.76;
    if (
      lastScrollStateRumi.current !== null &&
      lastScrollStateRumi.current !== isAbove089
    ) {
      if (kpopRumiRef.current) {
        gsap.killTweensOf(kpopRumiRef.current.rotation);

        if (isAbove089) {
          gsap.to(kpopRumiRef.current.rotation, {
            y: 0,
            duration: 1,
            ease: "power2.out",
          });
        } else {
          gsap.to(kpopRumiRef.current.rotation, {
            y: Math.PI / 2,
            duration: 2,
            ease: "power2.out",
          });
        }
      }
    }
    lastScrollStateRumi.current = isAbove089;

    const isAbove093 = currentProgress >= 0.85;
    if (
      lastScrollStateSign.current !== null &&
      lastScrollStateSign.current !== isAbove093
    ) {
      if (kpopSignRef.current) {
        gsap.killTweensOf(kpopSignRef.current.rotation);

        if (isAbove093) {
          gsap.to(kpopSignRef.current.rotation, {
            y: 0,
            duration: 1,
            ease: "power2.out",
          });
        } else {
          gsap.to(kpopSignRef.current.rotation, {
            y: Math.PI / 2,
            duration: 2,
            ease: "power2.out",
          });
        }
      }
    }
    lastScrollStateSign.current = isAbove093;

    randomOffsets.kpopRumi.time += delta;
    randomOffsets.kpopSign.time += delta;

    const rumiPosAmp = 0.03;
    const rumiRotAmp = 0.01;
    randomOffsets.kpopRumi.position.x =
      Math.sin(randomOffsets.kpopRumi.time * 1.3 + 0.5) * rumiPosAmp * 0.5;
    randomOffsets.kpopRumi.position.y =
      Math.sin(randomOffsets.kpopRumi.time * 1.6 + 1.2) * rumiPosAmp * 1.2;
    randomOffsets.kpopRumi.position.z =
      Math.sin(randomOffsets.kpopRumi.time * 1.1 + 2.4) * rumiPosAmp * 0.3;
    randomOffsets.kpopRumi.rotation.x =
      Math.sin(randomOffsets.kpopRumi.time * 0.9 + 0.8) * rumiRotAmp * 0.2;
    randomOffsets.kpopRumi.rotation.z =
      Math.sin(randomOffsets.kpopRumi.time * 0.8 + 2.2) * rumiRotAmp * 0.2;

    const signPosAmp = 0.025;
    const signRotAmp = 0.008;
    randomOffsets.kpopSign.position.x =
      Math.sin(randomOffsets.kpopSign.time * 0.7 + 1.1) * signPosAmp * 0.4;
    randomOffsets.kpopSign.position.y =
      Math.sin(randomOffsets.kpopSign.time * 0.9 + 0.6) * signPosAmp * 0.8;
    randomOffsets.kpopSign.position.z =
      Math.sin(randomOffsets.kpopSign.time * 0.6 + 1.9) * signPosAmp * 0.2;
    randomOffsets.kpopSign.rotation.x =
      Math.sin(randomOffsets.kpopSign.time * 0.8 + 1.7) * signRotAmp * 0.2;
    randomOffsets.kpopSign.rotation.z =
      Math.sin(randomOffsets.kpopSign.time * 0.7 + 2.6) * signRotAmp * 0.2;

    if (kpopRumiGroupRef.current) {
      kpopRumiGroupRef.current.position.set(
        26.255 -
          SHIFT_X_AMOUNT +
          randomOffsets.kpopRumi.basePosition.x +
          randomOffsets.kpopRumi.position.x,
        -0.937 +
          randomOffsets.kpopRumi.basePosition.y +
          randomOffsets.kpopRumi.position.y,
        -2.493 +
          randomOffsets.kpopRumi.basePosition.z +
          randomOffsets.kpopRumi.position.z
      );

      kpopRumiGroupRef.current.rotation.set(
        randomOffsets.kpopRumi.baseRotation.x +
          randomOffsets.kpopRumi.rotation.x,
        randomOffsets.kpopRumi.baseRotation.y,
        randomOffsets.kpopRumi.baseRotation.z +
          randomOffsets.kpopRumi.rotation.z
      );
    }

    if (kpopSignGroupRef.current) {
      kpopSignGroupRef.current.position.set(
        32.258 -
          SHIFT_X_AMOUNT +
          randomOffsets.kpopSign.basePosition.x +
          randomOffsets.kpopSign.position.x,
        9.876 +
          randomOffsets.kpopSign.basePosition.y +
          randomOffsets.kpopSign.position.y,
        -2.493 +
          randomOffsets.kpopSign.basePosition.z +
          randomOffsets.kpopSign.position.z
      );

      kpopSignGroupRef.current.rotation.set(
        randomOffsets.kpopSign.baseRotation.x +
          randomOffsets.kpopSign.rotation.x,
        randomOffsets.kpopSign.baseRotation.y,
        randomOffsets.kpopSign.baseRotation.z +
          randomOffsets.kpopSign.rotation.z
      );
    }
  });

  return (
    <group {...props} dispose={null}>
      <mesh
        geometry={nodes.Single_Sheet_Baked.geometry}
        material={singlesheet}
        position={[28.345 - SHIFT_X_AMOUNT, 4.634, -2.755]}
        rotation={[Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.Single_Sheet_Baked.geometry}
        material={singlesheet}
        position={[35.245 - SHIFT_X_AMOUNT, 4.634, -2.755]}
        rotation={[Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.Single_Sheet_Baked.geometry}
        material={singlesheet}
        position={[28.345 - SHIFT_X_AMOUNT, -3.42, -2.755]}
        rotation={[Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.Single_Sheet_Baked.geometry}
        material={singlesheet}
        position={[28.345 - SHIFT_X_AMOUNT - 6.9, -3.42, -2.755]}
        rotation={[Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.Single_Sheet_Baked.geometry}
        material={singlesheet}
        position={[35.245 - SHIFT_X_AMOUNT, -3.42, -2.755]}
        rotation={[Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.Single_Sheet_Baked.geometry}
        material={singlesheet}
        position={[35.245 - SHIFT_X_AMOUNT + 6.9, -3.42, -2.755]}
        rotation={[Math.PI / 2, 0, 0]}
      />

      <group ref={kpopRumiGroupRef}>
        <mesh
          ref={kpopRumiRef}
          geometry={nodes.rumi002.geometry}
          material={kpop}
          scale={[-0.999, -1, -0.447]}
          rotation={[0, Math.PI, 0]}
        />
      </group>

      <group ref={kpopSignGroupRef}>
        <mesh
          ref={kpopSignRef}
          geometry={nodes.rumi003.geometry}
          material={kpop}
          scale={[0.999, 1, 0.574]}
          rotation={[0, Math.PI, 0]}
        />
      </group>
    </group>
  );
}

useGLTF.preload("/models/single_sheet.glb");
